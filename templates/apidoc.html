{% extends 'base.html' %}

{% block head %}
	{% with fontawesome=False leaflet=False plotly=False %}
		{{ block.super }}
	{% endwith %}
{% endblock %}

{% block extra-head %}
<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism.min.css">
<style>
@media print {  /* https://stackoverflow.com/a/28441659 */
	div { float: none !important; position: static !important; display: block !important; 
          box-sizing: content-box !important; width: initial !important; max-width: initial !important;
    }
    body {
        height: initial !important;
        font-size: 1.5rem !important;
    }
    /* h2 {page-break-before: always !important;} */
    pre, blockquote {page-break-inside: avoid !important;}
}
p, ul, table{font-family: Lato, Helvetica, Arial, Tahoma, sans-serif;}
.h1, h1 {font-size: 3rem;}
.h2, h2 {font-size: 2.5rem;}
.h3, h3 {font-size: 2rem;}
.h4, h4 {font-size: 1.5rem;}
.h5, h5 {font-size: 1.25rem;}
.h6, h6 {font-size: 1rem;}
pre{overflow: initial;}
code{color: initial!important;}
pre[class*=language-] {overflow: initial!important;} /*override prism/chrome bug hiding making pre height 28em if the code inside overflows*/
table td{padding: .5rem; border:1px solid gray;text-align:initial}
</style>
{% endblock %}

{% block body %}
<div class='flexible flex-direction-col' style='align-items:center'>
<div class='flexible flex-direction-col text-justify px-5 py-3' style="width: 48rem;max-width: 100%;overflow:visible">

<h1>eGSIM API</h1>	

<p>
eGSIM is a web service for selecting and testing Ground
Shaking Intensity Models (GSIM) in Europe on top of  
<a target="_blank" href="https://github.com/GEMScienceTools/gmpe-smtk#gmpe-smtk">gmpe-smtk</a>,
a Python and
<a target="_blank" href="https://github.com/gem/oq-engine/#openquake-engine">OpenQuake</a>-based
toolkit for analysis of strong Motions and interpretation of Ground Motion Perdiciton Equations (GMPE).
As server-side web application programming interface (API), the goal
of eGSIM is to provide most of the toolkit functionalities via 
several publicly exposed endpoints (URLs) to a defined and easy to use requestâ€“response message
system.
</p>


<h2 id="generalfeatures">General features</h2>
<p>
eGSIM is implemented along the lines of typical web services (see e.g. the
<a target="_blank" href="https://www.fdsn.org/webservices/FDSN-WS-Specifications-1.1.pdf">FDSN protocol</a>):
<i>requests</i> can be issued by a client (eGSIM user) in several ways such as e.g. command line
applications like <code>wget</code> or inside client code with dedicated libraries
(e.g. Python's <code>urllib.request</code>). Requests require an endpoint, i.e. an URL denoting
a specific service, a method (GET vs POST) and usually parameters for tuning the functionality.
The web server processes the request and returns a <i>response</i> to the client in specific
formats described in the remainder of this document.
</p>


<h3 id="requestendpoints">Requests endpoints</h3> 
<p>
The following base URI pattern is to be used for each request:
</p>
<pre><code>{{ baseurl }}/&lt;service&gt;</code></pre>
<p>
where <code>&lt;service&gt;</code> is one of the following:
</p>
<ul>
	<li><code>{{ gsimsel }}</code> for <a href="#gsimselection"> Gsim selection</a> </li>
	<li><code>{{ trellis }}</code> for generating <a href="#trellisplots"> Trellis plots data</a> </li>
	<li><code>{{ residuals }}</code> for <a href="#residualanalysis"> Residual analysis</a> </li>
	<li><code>{{ test }}</code> for <a href="#testing">Testing</a> </li>
</ul>


<h3 id="requestmethods">Requests methods</h3>
<p>
eGSIM services will be invoked using a subset of REST and HTTP methods. In particular all services
will be invoked using the HTTP GET method whenever possible. As for FDSN web services,
the HTTP POST method might be invoked for the 
cases where the selection parameters are potentially large in size (typically, POST request
are used to send data to create/update a resource on the server. Unless otherwise stated,
this is generally not the case here).
</p>

<h4>GET method</h4>
<p>
Requests issued with the GET method simply concatenate the parameters names and
values directly in the URL:
</p>
<pre>{{ baseurl }}/&lt;service&gt;?<span class="token key atrule">name1</span>=<span class="token number">value1</span>&<span class="token key atrule">name2</span>=<span class="token number">value2</span></pre>

<h4>POST method</h4>
<p>
Requests issued with the POST should use the usual URI pattern:
<code>{{ baseurl }}/&lt;service&gt;</code>
and provide the parameters set by means of additional data as text in
<a target="_blank" href="https://en.wikipedia.org/wiki/JSON#Data_types.2C_syntax_and_example">JSON</a> or
<a target="_blank" href="https://en.wikipedia.org/wiki/YAML#Example">YAML</a> format.
The way the POST request has to be built with its data is responsibility of the user
as it depends on the client software. Python for instance has libraries to convert
<code>dict</code>s into JSON or YAML strings, or load external text files formatted in those
languages (the libraries <code>json</code> is built-in
and <code>PyYAML</code> can be easily installed) and the built-in <code>urllib</code> library
for sending HTTP request whose usage is documented
<a href='https://docs.python.org/3/howto/urllib2.html' target="_blank">here</a>. 
</p>

<h3 id="requestparameters">Request parameters</h3>
<p>
Request parameters can be input in three ways: in the URL of a GET request, in a YAML- or
JSON-formatted text file in case of POST request, or via input components of the
web Graphical User Interface (GUI) thorugh a web browser.

eGSIM supports the following parameter types:
</p>
<ul>
<li>numeric
<li>string
<li>boolean
<li>UTC date-time (in ISO format without timezone, e.g.:
<code>2016-01-30T23:15:11</code> or <code>2016-01-31</code>)
<li>arrays (vectors) of the previous types
<li>numeric ranges (i.e., equally spaced numeric arrays) in the Matlab(c) format <code>start:step:end</code>
(e.g. <code>0:0.1:0.3</code> results in the sequence of values 0, 0.1, 0.2, 0.3)
</ul>

<p>
For POST requests, most types are supported in YAML and JSON <i>except</i> numeric ranges, which must be
input as strings with quotes (e.g. <code>"0:0.1:0.3"</code>).
JSON does <b>not</b> support also date-times, which thus need 
to be input in the same way, e.g.: <code>"2016-01-31T23:15:00"</code> (in YAML, date-times as quoted strings are permitted
but not mandatory).
</p>
<p>
For GET request URLs, and
from within an input component of the Web GUI,
in all parameters <b>spaces, commas (,) and colons (:) are treated as special characters</b>:
As already described, the colon acts as separator for numeric ranges, whereas 
spaces and commas act as element separators in arrays (but only the comma is valid in GET requests URLs, being
spaces not allowed by definition).
Arrays can be input with or without leading and trailing square brackets, and no parameter value needs to be quoted.
</p>
<p>
 For instance, assuming a general <code>example</code> service requiring
three numeric parameters (dip, scalar, Vs<sub>30</sub>, array and ranges of
magnitudes) the user input, depending on the request's method, should look like:
</p>

<table class='paramexamples shadow-sm mb-3'>
<tr>
	<td>GET</td>
	<td colspan="2"><pre>{{ baseurl }}/example?dip=45&vs30=560,760&magnitude=3:0.5:5</pre></td>
</tr>
<tr>
	<td rowspan="3">POST</td>
	<td colspan="2">
		<pre>{{ baseurl }}/example</pre>
	</td>
</tr>
<tr>
	<td>data (YAML file)</td><td>data (JSON file)</td>
</tr>
<tr>
	<td><pre><code class="language-yaml">dip: 45
vs30:
 - 560
 - 760
magnitude: "3:0.5:5"
</code></pre></td>
	<td><pre><code class="language-json">{
  dip: 45, 
  vs30: [560, 760],
  magnitude: "3:0.5:5"
}</code></pre></td>
</tr>
<tr>
	<td>Web GUI components</td>
	<td colspan="2">
		<div><span style='display:inline-block;width:8rem'>Dip</span> <input type="number" value="45"/></div>
		<div><span style='display:inline-block;width:8rem'>Vs<sub>30</sub></span> <input type="text" value="560 760"/></div>
		<div><span style='display:inline-block;width:8rem'>Magnitude</span> <input type="text" value="3:0.5:5"/></div>
	</td>
</table>

<p>
The full description of the parameters and their constraints will be given in each service specific
section below.
</p>

<h3 id="responseerrors">Response errors</h3>
<p>
The response data type of a successfully fullfilled request depends on the service used and
the parameter issued in the request, and will be dealt in details in the next service specific sections.
On the other hand, unsuccessful requests might fail for several reasons. In case of client
or server errors, such as e.g. bad or missing parameters, eGSIM always returns responses
in JSON formatted byte strings following the <a href="https://google.github.io/styleguide/jsoncstyleguide.xml#Reserved_Property_Names_in_the_error_object" target="_blank">
google API specification</a>. Example:
</p>

<pre class="shadow-sm mb-3"><code class="language-python">
{
  # integer &ge;400 denoting HTTP error code:
  code: 400,
  # string denoting the error message associated with the code above:
  message: "input validation error",
  # optional array of parameter specific errors:
  errors: [ 
    {
      # string denoting the parameter name:
      domain: "magnitude",
      # string denoting the parameter specific error message:
      message: "This field is required.",
      # string denoting the parameter specific error reason:
      reason: "required"
    },
    ...
  ]
}
</code>
</pre>

<p>
For instance, this code snippet modified from the
<a href="https://docs.python.org/3/howto/urllib2.html" target="_blank">standard Python how-to reference</a>
shows how to issue a request to a eGSIM service and catch potential errors in both Python2 and 3
(tested with Python 2.7 and 3.6):
</p>

<pre class="shadow-sm mb-3">
<code class="language-python">
import json

# imports for Python3  (comment/remove in Python2):
from urllib.request import Request, urlopen
from urllib.error import URLError, HTTPError

# imports for Python2 (comment/remove in Python3):
from urllib2 import Request, urlopen, URLError, HTTPError

req = Request("write here your eGSIM endpoint URL")
try:
    data = urlopen(req)
except HTTPError as e2:
    # handle HTTP errors because of a server or client error, e.g.:
    print("Http error %d" % e2.code)
    # If you want to dig into details,
    # load the JSON formatted response into a Python dict:
    errordict = json.loads(e2.read())
    # now you can access fields such as
    # errordict.errors, errordict.message, ...
except URLError as e1:
    # handle general url errors like network errors. e.g.:
    print("Url error. Reason: %s" % e1.reason)
    raise
</code>
</pre>


<h2 id="services">Services</h2>
<p>
We call service an API module which returns a specific kind of data from a specific
endpoint URL and given parameters.
All services return a response whose data can be in various formats, generally
text (CSV format) and JSON are supported for all services.
The latter is usually supported in most programming languages and
can be converted very easily in client's code to an Object to work with. Example are
the Matlab <a href="https://www.mathworks.com/help/matlab/ref/jsondecode.html" target="_blank">jsonencode</a> function
or the Python builtin json library:   
</p>
<pre class="shadow-sm mb-3"><code class="language-python">
import json
# Given an request as url string ot Request object:
data = json.loads(urlopen(request))
# data is now a Python dictionary representing the request's JSON data
</code>
</pre>


<h3 id="gsimselection">Gsim selection</h3>
<p>
{{ form_gsims | safe }}
</p>

<h3 id="trellisplots">Trellis plots</h3>
<p>Endpoint:</p>
<pre>{{ baseurl }}/{{ trellis }}</pre>
<p>
<!-- The selection of GMPEs for use in probabilistic seismic hazard analysis should require an
understanding of the manner in which each GMPE characterises the ground motion scaling with
respect to the properties of the seismic source, and the attenuation of the motion with respect
to distance. This information can help in the interpretation of the seismic hazard results,
particularly those related to disaggregation, in order to best understand how the ground motion
prediction equation can influence the seismic hazard at a site. -->
The selection of GMPEs for use in probabilistic seismic hazard analysis should require an
understanding of the manner in which each GMPE characterises the ground motion scaling with
respect to the properties of the seismic source, and the attenuation of the motion with respect
to distance. In this framewrok, eGSIM can generate (by means of the underlying smtk library)
Trellis plot data of three types:
<ul>
<li> IMT vs Magnitude plots show how the ground motion intensity value scales with
respect to the magnitude of the rupture.
<li> IMT vs Distance plots allow to compare how the GMPEs describe the attenuation of strong
motion with distance for a given magnitude. 
<li> Magnitude-Distance spectra let the user understand how a
GMPE will scale the response spectrum with magnitude and distance.
</ul>
<p>
In addition to viewing the scaling of the expected ground motion from the GMPE,
it is also possible to view the scaling of the standard deviation, for a total of six
chosable plot types.
</p>

<h4>Request (input data)</h4>
<p>
A request to the Trellis plot service requires a list of GMPEs and IMTs,
the desired plot type and few other parameters configuring the scenario (rupture), most of which are
optional. As discussed, parameters can be given in the endpoint URL (GET method) or as
separate text data in JSON or YAML format (POST method) and are:
</p>

{{ form_trellis | safe }}

<h4>Request (output data)</h4>
<p>
A successful response will return the data relative to all generated Trellis plots. 
A feature of eGSIM is the ability to generate, for each given {{ param.imt }},
all combinations of Trellis plot for the following parameters, which can be input as 
numeric scalar or array: 
{{ param.magnitude }}, {{ param.distance }} and {{ param.vs30 }}:
</p>

<table>
<thead>
<tr>
	<td>Plot type</td>
	<td>Parameter setting the x values (should be numeric array):</td>
	<td>The number of generated plots is the prooduct of all values supplied for:</td></tr>
</thead>
<tbody>
<tr><td>IMT vs. distance</td><td>{{ param.distance }}</td><td>{{ param.imt }}, {{ param.magnitude }}, {{ param.vs30 }}</td></tr>
<tr><td>IMT vs. magnitude</td><td>{{ param.magnitude }}</td><td>{{ param.imt }}, {{ param.distance }}, {{ param.vs30 }}</td></tr>
<tr><td>Magnitude-distance spectra</td><td>None: a set of pre-defined periods will be used</td><td>{{ param.imt }}, {{ param.magnitude }}, {{ param.distance }}, {{ param.vs30 }}</td></tr>
</tbody>
</table>

<h5>JSON</h5>
<p>
Data returned in JSON format will have the following structure:
</p>
<pre class="shadow-sm mb-3"><code class="language-python">
{
  # list of x axis values, common to all Trellis plots:
  xvalues: [2.905, 3.771, ... ],
  # the x label, common to all x axis plot (string):
  xlabel: "Rupture Dist. (km)",
  # List of generated of Trellis plots:
  figures: [ 
    {
      # The plot y label:
      ylabel: "Median PGA (g)",
      # the magnitude set for this plot, numeric
      # (None if magnitudes are the x values):
      magnitude: 5,
      # the distance set for this plot, numeric
      # (None if distances are the x values):
      distance: None,
      # the vs30 set for this plot, numeric:
      vs30: 760,
      # object of plot's GMPE names (string),
      # mapped to their y values (numeric list):
      yvalues:{
      	"AkkarBommer2010": [0.3811, 0.3811, ...],
      	"CauzziFaccioli2008": [0.283, 0.283, ...],
      	...
      }
    },
    ...
  ]
}
</code>
</pre>

<!-- In IMT vs. distance plots, {{ param.distance }} needs to be input as numeric array, being
displayed as x axis. The number of generated plots will then result from all combinations
of {{ param.imt }}, {{ param.magnitude }}, {{ param.vs30 }}.
In IMT vs. magnitude plots, {{ param.magnitude }} needs to be input as numeric array, being
displayed as x axis. The number of generated plots will then result from all combinations
of {{ param.imt }}, {{ param.distance }}, {{ param.vs30 }}.
In Magnitude-distance plots, a set of pre-defined periods will be used as x axis values.
The number of generated plots will then result from all combinations
of {{ param.imt }}, {{ param.magnitude }}, {{ param.distance }} {{ param.vs30 }}.
</p> -->

<h3 id="residualanalysis">Residual analysis</h3>
<p>
</p>
{{ form_residuals | safe }}

<h3 id="testing">Testing</h3>
<p>

</p>

<h1>h1</h1>
<p>paragraph</p>
<h1>h2</h1>
<p>paragraph</p>
<h1>h3</h1>
<p>paragraph</p>
<h1>h4</h1>
<p>paragraph</p>
<h1>h5</h1>
<p>paragraph</p>
<h1>h6</h1>
<p>paragraph</p>
	
</div>
</div>
{% endblock %}

{% block after-body %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-json.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/data-uri-highlight/prism-data-uri-highlight.min.js"></script>

<script type='text/javascript'>
function setupH(h, secIndex, subsecIndex){
    var id = h.getAttribute('id');
    if (!id){
        id = h.innerText.replace(/ /g, '').toLowerCase();
        h.setAttribute('id', id);
    }
    var strNumber = `${secIndex}`;
    if (subsecIndex){
    	strNumber += `.${subsecIndex}`;
    }
    var text = h.innerHTML;
	var newText = `${secIndex}.${subsecIndex ? subsecIndex : ''} ${text} <a style='display:none' class="headerlink" href="#${id}" title="Permalink to this headline">&#182;</a>`;
	h.innerHTML = newText;
	// add mouseenter mouseleave. Note mouseout! see here:
	// https://javascript.info/mousemove-mouseover-mouseout-mouseenter-mouseleave#extra-mouseout-when-leaving-for-a-child
	h.onmouseenter = mouseevent => {
	    var target = mouseevent.target;
	    target.children[target.childElementCount-1].style.display = '';
	};
	h.onmouseleave = mouseevent => {
	    var target = mouseevent.target;
	    target.children[target.childElementCount-1].style.display = 'none';
	};
}
var [secIndex, subsecIndex] = [0, 0];
document.querySelectorAll('h2, h3').forEach((elm, index) => {
    var tag = elm.tagName.toLowerCase();
    if (tag == 'h2'){
        secIndex ++;
        subsecIndex = 0;
    }else{
        subsecIndex ++;
    }
    setupH(elm, secIndex, subsecIndex);
});
</script>

{% endblock %}
